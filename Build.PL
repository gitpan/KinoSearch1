use strict;
use warnings;
use 5.008003;
use Module::Build;
use File::Find qw( find );
use Storable qw( store retrieve );
use File::Spec::Functions qw( catfile );
use Fcntl;

=for comment

Build.PL file generates a slew of files on the fly before writing the Build
script.

=cut

my $ks_xs_filepath = 'KinoSearch1.xs';

# keep lists of which .c .h and .xs files need to be rewritten and cleaned up
my %needs_rewrite;

# retrieve a list of modification times from when Build.PL was last run
my $lastmod = -f 'lastmod' ? retrieve('lastmod') : {};

# If Build.PL was modified, force recompile of KinoSearch1.xs
my $build_pl_lastmod = ( stat('Build.PL') )[9];
if ( !exists $lastmod->{'Build.PL'}
    or $lastmod->{'Build.PL'} != $build_pl_lastmod )
{
    $needs_rewrite{$ks_xs_filepath} = 1;
}
$lastmod->{'Build.PL'} = $build_pl_lastmod;

# hold filepath => content pairs for generated files
my %code = ( $ks_xs_filepath => '' );
my %source_pm = ();

# grab all .pm filepaths, making sure that KinoSearch1.pm is first
my @pm_filepaths;
find(
    {   wanted => sub {
            if ( $File::Find::name =~ /KinoSearch1\.pm$/ ) {
                unshift @pm_filepaths, $File::Find::name;
            }
            elsif ( $File::Find::name =~ /\.pm$/ ) {
                push @pm_filepaths, $File::Find::name;
            }
        },
        no_chdir => 1,
    },
    'lib',
);

for my $pm_filepath (@pm_filepaths) {
    open( my $module_fh, '<', $pm_filepath )
        or die "couldn't open file '$pm_filepath': $!";
    my $module_text = do { local $/; <$module_fh> };
    my $outfilepath;

    # grab code that's delimited by an xs, c, or h __TAG__
    my $inside     = '';
    my $line_count = 0;
    while ( $module_text =~ /(.*?(?:\n|\r\n|\r))/g ) {
        $line_count++;
        my $line = $1;
        if ( $line =~ /^__(\w+)__/ ) {    # the tag to begin a block
            $inside = $1;
            if ( $inside eq 'XS' ) {
                # all XS code goes into one file: lib/KinoSearch1.xs
                $outfilepath = $ks_xs_filepath;
            }
            elsif ( $inside eq 'H' or $inside eq 'C' ) {
                # each .c and .h code section becomes its own file
                $outfilepath = $pm_filepath;
                $outfilepath =~ s/lib//;
                $outfilepath =~ s/\W//g;
                $outfilepath =~ s/pm$//;
                if ( $inside eq 'H' ) {
                    $outfilepath .= ".h";
                    # prepend an #include to KinoSearch1.xs
                    $code{$ks_xs_filepath}
                        = qq|#include "$outfilepath"\n$code{$ks_xs_filepath}|;
                }
                else {
                    $outfilepath .= ".c";
                }
                $outfilepath = catfile( 'src', $outfilepath );
                my $line_start = $line_count + 1;
                $code{$outfilepath} = qq|#line $line_start "$pm_filepath"\n|;
            }

            if ( $inside =~ /^(?:XS|H|C)$/ ) {
                # if the file has been modified, force a recompile
                my $mod_time = ( stat($module_fh) )[9];
                if ( !exists $lastmod->{$pm_filepath}{$inside}
                    or $lastmod->{$pm_filepath}{$inside} != $mod_time )
                {
                    $needs_rewrite{$outfilepath} = 1;
                }
                $lastmod->{$pm_filepath}{$inside} = $mod_time;
                $source_pm{$outfilepath} = $pm_filepath;
            }
        }
        elsif ( $inside =~ /^(?:XS|H|C)$/ ) {
            $code{$outfilepath} .= $line;
        }
    }
}

# write all the files that have been modified.
for my $outfilepath ( keys %needs_rewrite ) {
    my $autogen_header = <<"END_AUTOGEN";
/***********************************************

 !!!! DO NOT EDIT THIS FILE !!!!

 This file was auto-generated by Build.PL from
 $source_pm{$outfilepath}

 ***********************************************/

END_AUTOGEN

    print "Writing $outfilepath\n";
    unlink $outfilepath;
    sysopen( my $fh, $outfilepath, O_CREAT | O_EXCL | O_WRONLY )
        or die "Couldn't open file '$outfilepath' for writing: $!";
    print $fh "$autogen_header$code{$outfilepath}"
        or die "Print to '$outfilepath' failed: $!";

    close $fh or die "Couldn't close file '$outfilepath': $!";
}

=begin Rationale

All of KinoSearch1's C-struct types share the same typemap profile, but can't
be mapped to a single type.  Instead of tediously hand-editing the
typemap file, we autogenerate the file.  Adding a new type is now as simple as
adding an item to the @struct_classes array (provided it follows the same
pattern as all the others).

=end Rationale
=cut

# write the typemap file.
if ( $needs_rewrite{$ks_xs_filepath} ) {
    my @struct_classes = qw(
        KinoSearch1::Analysis::Stemmer::Stemmifier
        KinoSearch1::Analysis::Token
        KinoSearch1::Analysis::TokenBatch
        KinoSearch1::Index::SegTermEnum
        KinoSearch1::Index::TermBuffer
        KinoSearch1::Index::TermDocs
        KinoSearch1::Index::TermInfo
        KinoSearch1::Index::TermInfosWriter
        KinoSearch1::Search::HitCollector
        KinoSearch1::Search::MatchBatch
        KinoSearch1::Search::Scorer
        KinoSearch1::Search::Similarity
        KinoSearch1::Store::InStream
        KinoSearch1::Store::OutStream
        KinoSearch1::Util::BitVector
        KinoSearch1::Util::BoolSet
        KinoSearch1::Util::PriorityQueue
        KinoSearch1::Util::SortExternal
    );

    my $typemap_start  = qq|\nTYPEMAP\n|;
    my $typemap_input  = qq|\n\nINPUT\n|;
    my $typemap_output = qq|\n\nOUTPUT\n|;

    for my $struct_class (@struct_classes) {
        my ($ctype) = $struct_class =~ /([^:]+$)/;
        my $uc_ctype = uc($ctype);
        $ctype         .= ' *';
        $typemap_start .= "$ctype\t$uc_ctype\n";
        my $input_frag = <<'END_INPUT';
#UC_CTYPE#
    if (sv_derived_from($arg, \"#STRUCT_CLASS#\")) {
         $var = INT2PTR($type,( SvIV((SV*)SvRV($arg)) ) );
    }
    else
        Perl_croak(aTHX_ \"$var is not of type #STRUCT_CLASS#\")

END_INPUT
        $input_frag =~ s/#UC_CTYPE#/$uc_ctype/gsm;
        $input_frag =~ s/#STRUCT_CLASS#/$struct_class/gsm;
        $typemap_input .= $input_frag;

        my $output_frag .= <<'END_OUTPUT';
#UC_CTYPE#
    sv_setref_pv($arg, \"#STRUCT_CLASS#\", (void*)$var);

END_OUTPUT
        $output_frag =~ s/#UC_CTYPE#/$uc_ctype/gsm;
        $output_frag =~ s/#STRUCT_CLASS#/$struct_class/gsm;
        $typemap_output .= $output_frag;
    }

    # blast it out
    print "Writing typemap\n";
    unlink 'typemap';
    sysopen( my $typemap_fh, 'typemap', O_CREAT | O_WRONLY | O_EXCL )
        or die "Couldn't open 'typemap' for writing: $!";
    print $typemap_fh "# Auto-generated file.\n\n"
        or die "Print to 'typemap' failed: $!";
    print $typemap_fh "$typemap_start $typemap_input $typemap_output"
        or die "Print to 'typemap' failed: $!";
}

# record mod times in anticipation of Build.PL's next run
store( $lastmod, 'lastmod' );

my $builder = Module::Build->new(
    module_name       => 'KinoSearch1',
    license           => 'perl',
    dist_author       => 'Marvin Humphrey <marvin at rectangular dot com>',
    dist_version_from => 'lib/KinoSearch1.pm',
    requires          => {
        'Compress::Zlib'         => 0,
        'Lingua::Stem::Snowball' => 0.94,
        'Lingua::StopWords'      => 0.02,
    },
    build_requires => {
        'ExtUtils::CBuilder' => 0,
        'ExtUtils::ParseXS'  => 0,
    },
    create_makefile_pl => 'passthrough',
    #    extra_compiler_flags => [
    #        '-Wall',               '-Wextra',
    #        '-pedantic',           '-ansi',
    #        '-DPERL_GCC_PEDANTIC', '-std=c89',
    #        ],
    xs_files       => { $ks_xs_filepath => 'lib/KinoSearch1.xs' },
    c_source       => 'src',
    add_to_cleanup => [
        keys %code, 'KinoSearch1-*', 'typemap', 'MANIFEST.bak',
        'lastmod',  'perltidy.ERR',  '*.o',
    ],
);

my @no_index_files = qw(
    buildlib/KinoSearch1/Test/TestUtils.pm
    devel/dump_index
    devel/hexdebug
    devel/kinotidy
    devel/kinotidyrc
    devel/predit
    devel/scan_enum.plx
    devel/test_tidiness.plx
    devel/valgrind_test.plx
    lib/KinoSearch1/Index/CompoundFileReader.pm
    lib/KinoSearch1/Index/CompoundFileWriter.pm
    lib/KinoSearch1/Index/DelDocs.pm
    lib/KinoSearch1/Index/FieldInfos.pm
    lib/KinoSearch1/Index/FieldsReader.pm
    lib/KinoSearch1/Index/FieldsWriter.pm
    lib/KinoSearch1/Index/IndexFileNames.pm
    lib/KinoSearch1/Index/IndexReader.pm
    lib/KinoSearch1/Index/MultiReader.pm
    lib/KinoSearch1/Index/MultiTermDocs.pm
    lib/KinoSearch1/Index/NormsReader.pm
    lib/KinoSearch1/Index/PostingsWriter.pm
    lib/KinoSearch1/Index/SegInfos.pm
    lib/KinoSearch1/Index/SegReader.pm
    lib/KinoSearch1/Index/SegTermDocs.pm
    lib/KinoSearch1/Index/SegTermEnum.pm
    lib/KinoSearch1/Index/SegWriter.pm
    lib/KinoSearch1/Index/TermBuffer.pm
    lib/KinoSearch1/Index/TermDocs.pm
    lib/KinoSearch1/Index/TermEnum.pm
    lib/KinoSearch1/Index/TermInfo.pm
    lib/KinoSearch1/Index/TermInfosReader.pm
    lib/KinoSearch1/Index/TermInfosWriter.pm
    lib/KinoSearch1/Index/TermVector.pm
    lib/KinoSearch1/Search/BooleanClause.pm
    lib/KinoSearch1/Search/BooleanScorer.pm
    lib/KinoSearch1/Search/HitCollector.pm
    lib/KinoSearch1/Search/HitQueue.pm
    lib/KinoSearch1/Search/PhraseScorer.pm
    lib/KinoSearch1/Search/Scorer.pm
    lib/KinoSearch1/Search/Searchable.pm
    lib/KinoSearch1/Search/TermScorer.pm
    lib/KinoSearch1/Search/Weight.pm
    lib/KinoSearch1/Store/FSLock.pm
    lib/KinoSearch1/Store/InStream.pm
    lib/KinoSearch1/Store/Lock.pm
    lib/KinoSearch1/Store/OutStream.pm
    lib/KinoSearch1/Store/RAMLock.pm
    lib/KinoSearch1/Util/BitVector.pm
    lib/KinoSearch1/Util/ByteBuf.pm
    lib/KinoSearch1/Util/Carp.pm
    lib/KinoSearch1/Util/CClass.pm
    lib/KinoSearch1/Util/Class.pm
    lib/KinoSearch1/Util/IntMap.pm
    lib/KinoSearch1/Util/MathUtils.pm
    lib/KinoSearch1/Util/MemManager.pm
    lib/KinoSearch1/Util/PriorityQueue.pm
    lib/KinoSearch1/Util/SortExternal.pm
    lib/KinoSearch1/Util/StringHelper.pm
    lib/KinoSearch1/Util/ToolSet.pm
    lib/KinoSearch1/Util/ToStringUtils.pm
    lib/KinoSearch1/Util/VerifyArgs.pm
);

$builder->meta_add( { no_index => { files => \@no_index_files } } );

$builder->create_build_script();

